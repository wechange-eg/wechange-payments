# -*- coding: utf-8 -*-

from wechange_payments.conf import settings
from django.db import models
from django.contrib.postgres.fields.jsonb import JSONField
from django.utils.translation import ugettext_lazy as _
from datetime import datetime
from django.utils.timezone import now


class Payment(models.Model):
    
    TYPE_SEPA = 0
    
    #: Choices for :attr:`type`: ``(int, str)``
    TYPE_CHOICES = (
        (TYPE_SEPA, _('SEPA')),
    )
    
    user = models.ForeignKey(settings.AUTH_USER_MODEL, editable=False,
        related_name='payments', on_delete=models.CASCADE, null=False)
    vendor_transaction_id = models.CharField(_('Vendor Transaction Id'), max_length=50,
        help_text='An Id for the payment generated by the Payment Service')
    internal_transaction_id = models.CharField(_('Internal Transaction Id'), max_length=50,
        help_text='An Id for the payment generated by us')
    amount = models.FloatField(default='0.0')
    type = models.PositiveSmallIntegerField(_('Payment Type'), blank=False,
        default=TYPE_SEPA, choices=TYPE_CHOICES, editable=False)
    completed_at = models.DateTimeField(verbose_name=_('Completed At'), editable=False, auto_now_add=True)
    
    revoked = models.BooleanField(verbose_name=_('Has been revoked'), default=False)
    
    backend = models.CharField(_('Backend class used'), max_length=150)
    extra_data = JSONField()
    
    class Meta(object):
        app_label = 'wechange_payments'
        verbose_name = _('Payment')
        verbose_name_plural = _('Payments')


class TransactionLog(models.Model):
    
    TYPE_REQUEST = 0
    TYPE_POSTBACK = 1
    
    #: Choices for :attr:`type`: ``(int, str)``
    TYPE_CHOICES = (
        (TYPE_REQUEST, _('Direct Request')),
        (TYPE_POSTBACK, _('Received Postback')),
    )
    
    created = models.DateTimeField(verbose_name=_('Created'), editable=False, auto_now_add=True)
    url = models.CharField(_('API Endpoint URL'), max_length=150, null=True, blank=True)
    type = models.PositiveSmallIntegerField(_('Transaction Type'), blank=False,
        default=TYPE_REQUEST, choices=TYPE_CHOICES, editable=False)
    data = JSONField()
    
    class Meta(object):
        app_label = 'wechange_payments'
        verbose_name = _('Payment Transaction Log')
        verbose_name_plural = _('Payment Transaction Logs')


class Subscription(models.Model):
    
    # A cancelled subscription that no longer has any run-time left. There can be many of those.
    STATE_0_TERMINATED = 0
    # A cancelled subscription that still has run-time left because there was a recent payment.
    # As soon as the next_due_date arrives, this subscription will go to state 0.
    STATE_1_CANCELLED_BUT_ACTIVE = 1
    # Active
    STATE_2_ACTIVE = 2
    # A new subscription waiting for next payment due date, but with another subscription with the state STATE_1_CANCELLED_BUT_ACTIVE.
    STATE_3_WATING_TO_BECOME_ACTIVE = 3
    
    # A subscription can only ever go from higher number states to lower number states, never back up again!
    STATES = (
        (STATE_0_TERMINATED, _('Terminated.')),
        (STATE_1_CANCELLED_BUT_ACTIVE, _('Cancelled, but still active')),
        (STATE_2_ACTIVE, _('Active')),
        (STATE_3_WATING_TO_BECOME_ACTIVE, _('Waiting for next payment due date')),
    )
    
    user = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=_('User'), 
        editable=False, related_name='subscriptions', on_delete=models.CASCADE, null=False)
    reference_payment = models.OneToOneField('wechange_payments.Payment', verbose_name=_('Reference Payment'), 
        on_delete=models.PROTECT, related_name='subscription', null=False,
        help_text='The first payment for this subscription, which is also used to book any future payments.')
    payments = models.ManyToManyField('wechange_payments.Payment', verbose_name=_('All Payments'), 
        blank=True, related_name='+')
    
    state = models.PositiveSmallIntegerField(_('Subscription State'), blank=False,
        default=STATE_2_ACTIVE, choices=STATES, editable=False,
        help_text='A subscription can only ever go from higher number states to lower number states, never back up again!')
    has_problems = models.BooleanField(verbose_name=_('Has Problems'), default=False,
        help_text='An indicator flag that there were payment problems with the subscription\'s last payment. The subscription stays in active state however!')
    next_due_date = models.DateField(verbose_name=_('Next due date'), null=True, blank=True,
        help_text='Set to the next date whenever a payment is processed successfully.')
    
    amount = models.FloatField(verbose_name=_('Amount'), default='0.0', editable=False)
    created = models.DateTimeField(verbose_name=_('Created'), editable=False, auto_now_add=True)
    last_payment = models.ForeignKey('wechange_payments.Payment', verbose_name=_('Last Payment'), 
        on_delete=models.PROTECT, related_name='+', null=False,
        help_text='The most recent payment made.')
    
    class Meta(object):
        ordering = ('created',)
        verbose_name = _('Subscription')
        verbose_name_plural = _('Subscription')
        
    def validate_state_and_cycle(self):
        """ This will also terminate this subscription if it has been cancelled, 
            and whose next_due_date is in the past! 
            If an old subscription has been terminated, this will check if there
            is a new waiting subscription to be activated. """
        raise Exception('NYI')
    
    def check_payment_due(self):
        """ Returns true if the subscription is active and `next_due_date` is in the past or today. """
        if self.state == self.STATE_2_ACTIVE:
            return self.get_next_payment_date() <= now().date()
        return False
        
    def get_next_payment_date(self):
        """ Returns a Date of the next due payment date """
        if self.state == self.STATE_2_ACTIVE:
            self.next_due_date
        return None
    
    def set_next_due_date(self, last_target_date):
        """ Sets the `next_due_date` based on the date of the last target date.
            This will set the due date to the target date's next month, with the day of month of the reference payment,
            or the last day of month if it is a shorter month.
            Called after a recurring payment has been successfully made. """
        # todo: sanity check: check if timedelta.days is > 20 or so!
        raise Exception('NYI')
    
